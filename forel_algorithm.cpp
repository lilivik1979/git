#include <iostream> // Подключает стандартную библиотеку ввода/вывода (включает cout, cin и т.д.)
#include <vector> // Подключает стандартную библиотеку для работы с динамическими массивами (векторами)
#include <fstream> // Подключает стандартную библиотеку для работы с файлами (ifstream, ofstream)
#include <cstdlib> // Подключает библиотеку функций из C (включая rand и srand)
#include <cmath> // Подключает математическую библиотеку (включая sqrt и pow)
#include <ctime> // Подключает библиотеку для работы со временем (для инициализации генератора случайных чисел)

using namespace std; // Использует пространство имен std, чтобы не писать std:: перед стандартными элементами (например, cout, vector)

// Структура для хранения точки с координатами x и y, и номером класса
struct Point {
    double x; // Координата x точки
    double y; // Координата y точки
    int class_num; // Номер класса, к которому принадлежит точка
};

// Функция для вычисления евклидова расстояния между двумя точками
double euclidean_distance(const Point &a, const Point &b) { // Принимает две точки в качестве константных ссылок
    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2)); // Возвращает евклидово расстояние между точками a и b
}

// Алгоритм Forel
void forel(const vector<Point> &data, int k) { // Принимает вектор точек и желаемое количество кластеров k
    int n = data.size(); // Сохраняем количество точек данных в переменной n
    vector<Point> centroids(k); // Создаем вектор центроидов (центров кластеров) размером k
    vector<int> labels(n, 0); // Создаем вектор меток (номеров кластеров), изначально все точки относятся к кластеру 0

    // Инициализируем центры кластеров случайным образом
    srand(time(0)); // Инициализирует генератор случайных чисел, используя текущее время в качестве начального значения (seed)
    for (int i = 0; i < k; ++i) { // Цикл для инициализации каждого центроида
        centroids[i] = data[rand() % n]; // Присваивает случайную точку из набора данных в качестве начального центроида
    }

    bool converged = false; // Флаг сходимости, изначально алгоритм не сошелся

    while (!converged) { // Цикл продолжается, пока алгоритм не сойдется
        // Присваиваем точки ближайшим центрам
        for (int i = 0; i < n; ++i) { // Цикл по каждой точке данных
            double min_distance = euclidean_distance(data[i], centroids[0]); // Вычисляем расстояние до первого центроида
            labels[i] = 0; // Предполагаем, что точка относится к первому кластеру

            for (int j = 1; j < k; ++j) { // Цикл по остальным центроидам
                double distance = euclidean_distance(data[i], centroids[j]); // Вычисляем расстояние до текущего центроида
                if (distance < min_distance) { // Если расстояние меньше минимального
                    min_distance = distance; // Обновляем минимальное расстояние
                    labels[i] = j; // Обновляем метку кластера для текущей точки
                }
            }
        }

        // Обновляем центры кластеров
        vector<Point> new_centroids(k); // Создаем новый вектор центроидов
        vector<int> counts(k, 0); // Создаем вектор для подсчета количества точек в каждом кластере

        for (int i = 0; i < n; ++i) { // Цикл по каждой точке данных
            new_centroids[labels[i]].x += data[i].x; // Суммируем координаты x точек в каждом кластере
            new_centroids[labels[i]].y += data[i].y; // Суммируем координаты y точек в каждом кластере
            counts[labels[i]]++; // Увеличиваем счетчик точек в соответствующем кластере
        }

        for (int j = 0; j < k; ++j) { // Цикл по каждому кластеру
            if (counts[j] > 0) { // Если в кластере есть точки
                new_centroids[j].x /= counts[j]; // Вычисляем среднее значение координаты x для центроида
                new_centroids[j].y /= counts[j]; // Вычисляем среднее значение координаты y для центроида
            } else {
                new_centroids[j] = data[rand() % n]; // Если кластер пустой, выбираем случайную точку в качестве нового центроида
            }
        }

        // Проверяем сходимость
        converged = true; // Предполагаем, что алгоритм сошелся
        for (int j = 0; j < k; ++j) { // Цикл по каждому кластеру
            if (euclidean_distance(centroids[j], new_centroids[j]) > 1e-6) { // Если расстояние между старым и новым центроидом больше порога
                converged = false; // Алгоритм не сошелся
                break; // Выходим из цикла
            }
        }

        centroids = new_centroids; // Обновляем центроиды
    }

    // Сохраняем результаты в файл
    ofstream outfile("result1.txt"); // Открываем файл для записи результатов
    for (int i = 0; i < n; ++i) { // Цикл по каждой точке
        outfile << data[i].x << " " << data[i].y << " " << labels[i] + 1 << endl; // Записываем координаты точки и номер кластера (+1, чтобы номера начинались с 1)
    }
    outfile.close(); // Закрываем файл

    // Сохраняем центры кластеров в файл
    ofstream centroid_outfile("centroids.txt"); // Открываем файл для записи центроидов
    for (const auto &centroid : centroids) { // Цикл по каждому центроиду
        centroid_outfile << centroid.x << " " << centroid.y << endl; // Записываем координаты центроида
    }
    centroid_outfile.close(); // Закрываем файл
}

int main() {
    // Считываем данные из файла
    vector<Point> data; // Создаем вектор для хранения точек
    ifstream infile("data.txt"); // Открываем файл с данными
    
    double x, y; // Переменные для хранения координат x и y
    while (infile >> x >> y) { // Цикл чтения данных из файла
        data.push_back({x, y, 0}); // Добавляем точку в вектор data (номер класса пока не важен)
    }
    infile.close(); // Закрываем файл

    int k = 3; // Задаем количество кластеров
    forel(data, k); // Вызываем функцию forel для кластеризации данных

    return 0; // Возвращаем 0, если программа завершилась успешно
}